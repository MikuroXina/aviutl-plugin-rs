# aviutl-plugin-rs

The AviUtl plugin framework with Rust.

## Usage

This library is organized as four modules: `color`, `filter`, `input`, `output`. Each one provides own `prelude` module that helps you to develop your plugin for AviUtl easily.

At first, you need to set up your project to generate Window32 DLL as below:

1. Create your Rust project as a library.
    ```sh
    cargo new --lib your-awesome-plugin
    cd your-awesome-plugin
    ```
2. Set `crate-type` to `cdylib` in `Cargo.toml`.
    ```toml
    [lib]
    crate-type = ["cdylib"]
    ```
3. Code your plugin. About coding a plugin, see sections below.
4. Build with `i686-pc-windows-msvc`, 32-bit Windows target.
    ```sh
    rustup target add i686-pc-windows-msvc
    cargo build --target=i686-pc-windows-msvc
    ```
5. Your DLL file will be generated in `target/i686-pc-window-msvc/debug`.

### `color` module

You can create a color conversion plugin with this.

This provides `ColorPlugin` trait that requires constants and implementations needed to generate the plugin table. It is needed to export as DLL by `export_color_plugin` macro, generates an external function.

```rs
use aviutl_plugin::color::prelude::*;

#[derive(Debug, Default)]
struct ExamplePlugin;

// Don't forget!
export_color_plugin!(ExamplePlugin);

impl ColorPlugin for ExamplePlugin {
    const NAME: &'static str = "ExampleCC";
    const INFORMATION: &'static str = "Example color converter";
    fn pixel_to_yc(&mut self, proc_info: &ProcInfo, from: &[u8], to: &mut [PixelYc]) -> Result<()> {
        // Convert your pixels into YCbCr pixels.
        Ok(())
    }
    fn yc_to_pixel(&mut self, proc_info: &ProcInfo, from: &[PixelYc], to: &mut [u8]) -> Result<()> {
        // Convert YCbCr pixel into your pixels.
        Ok(())
    }
}
```

### `filter` module

You can create a filter (but also others) plugin with this.

This provides `FilterPlugin` trait that requires constants and implementations needed to generate the plugin table. It is needed to export as DLL by `export_filter_plugin` macro, generates an external function.

```rs
use aviutl_plugin::filter::prelude::*;

#[derive(Debug, Default)]
struct ExamplePlugin;

// Don't forget!
export_filter_plugin!(ExamplePlugin);

impl FilterPlugin for ExamplePlugin {
    const NAME: &'static str = "ExampleF";
    const INFORMATION: &'static str = "Example filter";

    // Specify flags to activate some features by AviUtl. For more details, see docs.
    const FLAGS: FilterPluginFlag = FilterPluginFlag::EX_INFORMATION;

    // You can defined tracks and controls in a window generated by AviUtl.
    const TRACKS: &'static [Track] = &[];
    const CONTROLS: &'static [Control] = &[];
    const WINDOW_SIZE: Size = Size::new();

    // And some event handlers in FilterPlugin make you to be able to do anything!
}
```

### `input` module

You can create a file input plugin with this.

This provides `InputPlugin` trait that requires constants and implementations needed to generate the plugin table. It is needed to export as DLL by `export_input_plugin` macro, generates an external function.

```rs
use aviutl_plugin::input::prelude::*;

#[derive(Debug, Default)]
struct ExamplePlugin;

// Don't forget!
export_input_plugin!(ExamplePlugin);

impl InputPlugin for ExamplePlugin {
    // Specify your file handle type.
    type Handle: InputHandle = ExampleHandle;

    const NAME: &'static str = "ExampleL";
    const INFORMATION: &'static str = "Example loader";

    fn file_filters() -> FileFilters {
        // Returns a file filter, what file type does your plugin supported.
    }

    fn open(&mut self, path: Cow<'_, str>) -> Result<Self::Handle> {
        // Open file in `path` with your file handle.
    }
    fn close(&mut self, handle: Self::Handle) -> Result<()> {
        // Close you file handle.
    }
}

struct ExampleHandle;

impl InputHandle for ExampleHandle {
    // You need to impl some methods that allows AviUtl to read video and audio. See InputHandle doc.
}
```


### `output` module

You can create a file output plugin with this.

This provides `OutputPlugin` trait that requires constants and implementations needed to generate the plugin table. It is needed to export as DLL by `export_output_plugin` macro, generates an external function.

```rs
use aviutl_plugin::output::prelude::*;

#[derive(Debug, Default)]
struct ExamplePlugin;

// Don't forget!
export_output_plugin!(ExamplePlugin);

impl OutputPlugin for ExamplePlugin {
    const NAME: &'static str = "ExampleE";
    const INFORMATION: &'static str = "Example exporter";

    fn file_filters() -> FileFilters {
        // Returns a file filter, what file type does your plugin supported.
    }

    fn output(&mut self, info: Info) -> Result<()> {
        // Export the project as any format you want.
        Ok(())
    }
}
```
